"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkRevive = exports.Night_Police = exports.Night_Doctor = exports.Night_Mafia = exports.checkFinish = exports.Vote = exports.Day = exports.decideJob = exports.initGame = void 0;
const discord_js_1 = require("discord.js");
const MAX_PLAYERS = 2; //DEBUG 8
const jobList = {
    MAFIA_1: 1,
    MAFIA_2: 2,
    DOCTOR: 3,
    POLICE: 4,
};
const voteEmoji = ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£"];
const START_TIME = 0; //DEBUG 10000
const DAY_TIME = 120000; //DEBUG 120000
const VOTE_TIME = 30000; //DEBUG 30000
function generateUniqueRandomNumbers(max, count) {
    const numbers = [];
    while (numbers.length < count) {
        const randomNumber = Math.floor(Math.random() * max) + 1;
        if (!numbers.includes(randomNumber)) {
            numbers.push(randomNumber);
        }
    }
    return numbers;
}
function timeout(time) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve();
        }, time);
    });
}
function initGame(client, msg, currentGamingGuildList) {
    return __awaiter(this, void 0, void 0, function* () {
        if (currentGamingGuildList.includes(msg.guildId)) {
            msg.channel.send("ÏÑúÎ≤ÑÏóê Ïù¥ÎØ∏ Í≤åÏûÑÏù¥ ÏßÑÌñâÏ§ëÏûÖÎãàÎã§.");
            return;
        }
        const initMsg = yield msg.channel.send("Ï∞∏Í∞ÄÌï† ÌîåÎ†àÏù¥Ïñ¥Îäî üëç Ïù¥Î™®Ìã∞ÏΩòÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî(30Ï¥à)!");
        initMsg.react("üëç");
        currentGamingGuildList.push(msg.guildId);
        const collector = new discord_js_1.ReactionCollector(initMsg, {
            filter: (reaction, user) => {
                return (reaction.emoji.name === "üëç" &&
                    !user.bot &&
                    !memberListMsg.content.includes(user.username));
            },
            time: 30000,
            max: MAX_PLAYERS,
        });
        const membersID = [];
        const memberListMsg = yield msg.channel.send("Ï∞∏Í∞ÄÌï† ÌîåÎ†àÏù¥Ïñ¥ Î™©Î°ù : ");
        collector.on("collect", (_reaction, user) => __awaiter(this, void 0, void 0, function* () {
            membersID.push(user.id);
            memberListMsg.edit(memberListMsg.content + " " + user.username);
        }));
        const result = yield new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            collector.on("end", (collected) => __awaiter(this, void 0, void 0, function* () {
                if (membersID.length == MAX_PLAYERS) {
                    msg.channel.send("Í≤åÏûÑÏù¥ ÏãúÏûëÎê©ÎãàÎã§.");
                    console.log(`${msg.guild.name} ÏÑúÎ≤ÑÏóêÏÑú Í≤åÏûÑÏù¥ ÏãúÏûëÎêòÏóàÏäµÎãàÎã§.`);
                    resolve([client, msg, membersID, currentGamingGuildList]);
                }
                else {
                    msg.channel.send(`Ïù∏ÏõêÏù¥ Î∂ÄÏ°±ÌïòÏó¨ Í≤åÏûÑÏùÑ ÏãúÏûëÌï† Ïàò ÏóÜÏäµÎãàÎã§. (${MAX_PLAYERS - collected.size}Î™Ö Î∂ÄÏ°±)`);
                    currentGamingGuildList = currentGamingGuildList.filter((element) => element !== msg.guildId);
                    resolve();
                }
            }));
        }));
        return result;
    });
}
exports.initGame = initGame;
function decideJob(client, msg, membersID, currentGamingGuildList) {
    return __awaiter(this, void 0, void 0, function* () {
        let memberObjects = [];
        const rand_numbers = generateUniqueRandomNumbers(MAX_PLAYERS, MAX_PLAYERS);
        for (let i = 0; i < MAX_PLAYERS; i++) {
            const user = client.users.cache.get(membersID[i]);
            const job = rand_numbers[i];
            yield user.createDM().then((dmChannel) => {
                memberObjects.push({ user, job, dmChannel });
            });
        }
        for (let i = 0; i < MAX_PLAYERS; i++) {
            let jobRevealMessage = "ÎãπÏã†Ïùò ÏßÅÏóÖÏùÄ ";
            switch (memberObjects[i].job) {
                case jobList.MAFIA_1:
                case jobList.MAFIA_2:
                    jobRevealMessage += "ÎßàÌîºÏïÑÏûÖÎãàÎã§.";
                    break;
                case jobList.DOCTOR:
                    jobRevealMessage += "ÏùòÏÇ¨ÏûÖÎãàÎã§.";
                    break;
                case jobList.POLICE:
                    jobRevealMessage += "Í≤ΩÏ∞∞ÏûÖÎãàÎã§.";
                    break;
                default:
                    jobRevealMessage += "ÏãúÎØºÏûÖÎãàÎã§.";
                    break;
            }
            memberObjects[i].dmChannel.send(jobRevealMessage);
        }
        memberObjects
            .find((member) => member.job === jobList.MAFIA_1)
            .dmChannel.send(`${memberObjects.find((member) => member.job === jobList.MAFIA_2).user
            .username}ÏùÄ(Îäî) ÎßàÌîºÏïÑÏûÖÎãàÎã§.`);
        memberObjects
            .find((member) => member.job === jobList.MAFIA_2)
            .dmChannel.send(`${memberObjects.find((member) => member.job === jobList.MAFIA_1).user
            .username}ÏùÄ(Îäî) ÎßàÌîºÏïÑÏûÖÎãàÎã§.`);
        msg.channel.send("ÏßÅÏóÖÏù¥ Î™®Îëê Í≤∞Ï†ïÎêòÏóàÏäµÎãàÎã§. 10Ï¥à ÌõÑ Í≤åÏûÑÏù¥ ÏãúÏûëÎê©ÎãàÎã§.");
        yield timeout(START_TIME);
        return [msg, memberObjects, currentGamingGuildList];
    });
}
exports.decideJob = decideJob;
function Day(msg, memberObjects, currentGamingGuildList) {
    return __awaiter(this, void 0, void 0, function* () {
        yield msg.channel.send("ÏïÑÏπ®Ïù¥ Î∞ùÏïòÏäµÎãàÎã§. 2Î∂Ñ ÎèôÏïà ÏûêÏú†ÌÜ†Î°†ÏùÑ Ìï† Ïàò ÏûàÏäµÎãàÎã§.");
        yield msg.channel.send("ÏïÑÏπ®ÏùÑ Ïä§ÌÇµÌïòÏãúÎ†§Î©¥ Í≥ºÎ∞òÏàò Ïù¥ÏÉÅÏù¥ Ï±ÑÌåÖÏóê '!Ïä§ÌÇµ'ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.");
        let skipList = [];
        const skipCollector = new discord_js_1.MessageCollector(msg.channel, {
            filter: (msg, _collection) => {
                return (msg.content === "!Ïä§ÌÇµ" &&
                    !skipList.includes(msg.author.id) &&
                    memberObjects.some((obj) => obj.user.id === msg.author.id));
            },
            time: DAY_TIME,
            max: memberObjects.length % 2 == 0
                ? Math.floor(memberObjects.length / 2)
                : Math.floor(memberObjects.length / 2) + 1,
        });
        skipCollector.on("collect", (msg, _collection) => {
            skipList.push(msg.author.id);
            msg.channel.send(`${msg.author.username}ÎãòÏù¥ Ïä§ÌÇµÏóê Ï∞¨ÏÑ±ÌïòÏÖ®ÏäµÎãàÎã§.`);
        });
        const result = yield new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            skipCollector.on("end", (_collected) => __awaiter(this, void 0, void 0, function* () {
                yield msg.channel.send("ÏïÑÏπ®Ïù¥ ÎÅùÎÇ¨ÏäµÎãàÎã§. Ìà¨ÌëúÍ∞Ä ÏßÑÌñâÎê©ÎãàÎã§.");
                resolve([msg, memberObjects, currentGamingGuildList]);
            }));
        }));
        return result;
    });
}
exports.Day = Day;
function Vote(msg, memberObjects, currentGamingGuildList) {
    return __awaiter(this, void 0, void 0, function* () {
        const embed = new discord_js_1.EmbedBuilder({
            title: "Ìà¨Ìëú (30Ï¥à)",
            description: "Ï∂îÎ∞©Ìï† ÏÇ¨ÎûåÏùò Î≤àÌò∏Ïóê ÎßûÎäî Ïù¥Î™®Ìã∞ÏΩòÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.",
        }).addFields(memberObjects.map((member, i) => {
            return { name: member.user.username, value: `${i + 1}Î≤à` };
        }));
        const embeddedMessage = yield msg.channel.send({ embeds: [embed] });
        for (let i = 0; i < memberObjects.length; i++) {
            yield embeddedMessage.react(voteEmoji[i]);
        }
        let votedMember = [];
        const votedAmount = new Array(memberObjects.length).fill(0);
        const voteEmojiCollector = new discord_js_1.ReactionCollector(embeddedMessage, {
            filter: (reaction, user) => {
                return voteEmoji.includes(reaction.emoji.name) && !user.bot;
            },
            time: VOTE_TIME,
            dispose: true,
        });
        voteEmojiCollector.on("collect", (reaction, user) => __awaiter(this, void 0, void 0, function* () {
            if (votedMember.some((member) => member.user_id === user.id))
                return;
            votedAmount[voteEmoji.indexOf(reaction.emoji.name)]++;
            votedMember.push({
                user_id: user.id,
                voted: voteEmoji.indexOf(reaction.emoji.name),
            });
            yield msg.channel.send(`${user.username}ÎãòÏù¥ ${voteEmoji.indexOf(reaction.emoji.name) + 1}Î≤àÏóê Ìà¨ÌëúÌïòÏÖ®ÏäµÎãàÎã§.`);
        }));
        voteEmojiCollector.on("remove", (reaction, user) => __awaiter(this, void 0, void 0, function* () {
            if (votedMember.find((element) => {
                return element.user_id === user.id;
            }) === undefined) {
                return;
            }
            if (votedMember.find((element) => {
                return element.user_id === user.id;
            }).voted !== voteEmoji.indexOf(reaction.emoji.name)) {
                return;
            }
            votedMember = votedMember.filter((element) => element.user_id !== user.id);
            votedAmount[voteEmoji.indexOf(reaction.emoji.name)]--;
            yield msg.channel.send(`${user.username}ÎãòÏù¥ ${voteEmoji.indexOf(reaction.emoji.name) + 1}Î≤à Ìà¨ÌëúÎ•º Ï∑®ÏÜåÌñàÏäµÎãàÎã§.`);
        }));
        const result = yield new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            voteEmojiCollector.on("end", (_collected) => __awaiter(this, void 0, void 0, function* () {
                yield msg.channel.send("Ìà¨Ìëú Ï¢ÖÎ£å. Í≤∞Í≥ºÎ•º Í≥ÑÏÇ∞ Ï§ëÏûÖÎãàÎã§...");
                let max_vote = 0;
                let dropped_list = [];
                for (let i = 0; i < memberObjects.length; i++) {
                    if (votedAmount[i] > max_vote) {
                        max_vote = votedAmount[i];
                        dropped_list = [];
                        dropped_list.push(memberObjects[i]);
                    }
                    else if (votedAmount[i] == max_vote) {
                        dropped_list.push(memberObjects[i]);
                    }
                }
                if (max_vote == 0)
                    dropped_list = [];
                if (dropped_list.length == 1) {
                    //Ï∂îÎ∞© ÌåêÏ†ï
                    //ÏµúÎã§ ÎìùÌëúÍ∞Ä 1Î™Ö(Ï∂îÎ∞©)
                    yield msg.channel.send(`${dropped_list[0].user.username}ÎãòÏù¥ ÏµúÎã§ ÎìùÌëúÎ°ú Ï∂îÎ∞©ÎêòÏóàÏäµÎãàÎã§. (${max_vote}Ìëú)`);
                    if (dropped_list[0].job == jobList.MAFIA_1 ||
                        dropped_list[0].job == jobList.MAFIA_2) {
                        yield msg.channel.send("Í∑∏Îäî ÎßàÌîºÏïÑÏòÄÏäµÎãàÎã§.");
                    }
                    memberObjects = memberObjects.filter((object) => {
                        return object !== dropped_list[0];
                    });
                }
                else if (dropped_list.length > 1) {
                    //ÏµúÎã§ ÎìùÌëúÍ∞Ä Ïó¨Îü¨ Î™Ö
                    yield msg.channel.send(`${dropped_list.length}Î™ÖÏùò ÏµúÎã§ ÎìùÌëúÏûêÍ∞Ä ÎÇòÏôÄ Ìà¨ÌëúÍ∞Ä Î¨¥Ìö® Ï≤òÎ¶¨ÎêòÏóàÏäµÎãàÎã§. (${max_vote}Ìëú)`);
                }
                else {
                    //ÎìùÌëú ÏóÜÏùå(Í∏∞Í∂å)
                    yield msg.channel.send("Ìà¨ÌëúÍ∞Ä 0ÌëúÏù¥ÎØÄÎ°ú ÏûêÎèô Í∏∞Í∂å Ï≤òÎ¶¨Îê©ÎãàÎã§.");
                }
                resolve([msg, memberObjects, currentGamingGuildList]);
            }));
        }));
        return result;
    });
}
exports.Vote = Vote;
function checkFinish(msg, memberObjects, currentGamingGuildList) {
    return __awaiter(this, void 0, void 0, function* () {
        /*   let mafia_num = 0;
        for (let i = 0; i < memberObjects.length; i++) {
          if (
            memberObjects[i].job == jobList.MAFIA_1 ||
            memberObjects[i].job == jobList.MAFIA_2
          ) {
            mafia_num++;
          }
        }
      
        return await new Promise<
          | boolean
          | [msg: Message, memberObjects: memObject, currentGamingGuildList: string[]]
        >(async () => {
          let civilian_num = memberObjects.length - mafia_num;
          if (mafia_num >= civilian_num || mafia_num == 0) {
            //Í≤åÏûÑ Ï¢ÖÎ£å
            let gameOverMessage = "Í≤åÏûÑÏù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§. ";
            const mafia_win = mafia_num == 0 ? false : true;
            if (mafia_win) {
              gameOverMessage +=
                "ÎßàÌîºÏïÑ ÏäπÎ¶¨ (ÏãúÎØºÏùò ÏàòÍ∞Ä ÎßàÌîºÏïÑÎ≥¥Îã§ Ï†ÅÍ±∞ÎÇò Í∞ôÏäµÎãàÎã§.)";
            } else {
              gameOverMessage += "ÏãúÎØºÌåÄ ÏäπÎ¶¨ (ÎßàÌîºÏïÑÍ∞Ä Ï†ÑÎ∂Ä Ï†úÍ±∞ÎêòÏóàÏäµÎãàÎã§.)";
            }
            await msg.channel.send(gameOverMessage);
      
            currentGamingGuildList.splice(
              currentGamingGuildList.indexOf(msg.guildId),
              1
            );
            console.log(`${msg.guild.name} ÏÑúÎ≤ÑÏóêÏÑú Í≤åÏûÑÏù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.`);
            return false;
          } else {
            await msg.channel.send("Î∞§Ïù¥ Ï∞æÏïÑÏòµÎãàÎã§...");
            return [msg, memberObjects, currentGamingGuildList];
          }
         
        }); */
        yield msg.channel.send("Î∞§Ïù¥ Ï∞æÏïÑÏòµÎãàÎã§...");
        return [msg, memberObjects, currentGamingGuildList];
    });
}
exports.checkFinish = checkFinish;
function Night_Mafia(msg, memberObjects, currentGamingGuildList) {
    return __awaiter(this, void 0, void 0, function* () {
        yield msg.channel.send("ÎßàÌîºÏïÑÏùò Ï∞®Î°ÄÏûÖÎãàÎã§.");
        const mafiaList = [];
        const mafiaVoteMessageList = [];
        const emojiCollectorList = [];
        const msgCollectorList = [];
        mafiaList.push(memberObjects.find((member) => member.job === jobList.MAFIA_1));
        mafiaList.push(memberObjects.find((member) => member.job === jobList.MAFIA_2));
        const embed = new discord_js_1.EmbedBuilder({
            title: "Ìà¨Ìëú (30Ï¥à)",
            description: "Ï≤òÎ¶¨Ìï† ÏÇ¨ÎûåÏùò Î≤àÌò∏Ïóê ÎßûÎäî Ïù¥Î™®Ìã∞ÏΩòÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.",
        }).addFields(memberObjects.map((member, i) => {
            return { name: member.user.username, value: `${i + 1}Î≤à` };
        }));
        const votedAmount = [];
        for (let i = 0; i < mafiaList.length; i++) {
            mafiaVoteMessageList.push(yield mafiaList[i].dmChannel.send({ embeds: [embed] }));
            yield mafiaList[i].dmChannel.send("Ìà¨ÌëúÎ•º ÌÜµÌï¥ Ï≤òÎ¶¨Ìï† ÏÇ¨ÎûåÏùÑ Í≤∞Ï†ïÌï¥Ï£ºÏÑ∏Ïöî.\nÏù¥ Ï±ÑÌåÖÎ∞©Ïóê Ï±ÑÌåÖÏùÑ ÏûÖÎ†•ÌïòÎ©¥ Îòê Îã§Î•∏ ÎßàÌîºÏïÑÏôÄ ÏÜåÌÜµÌï† Ïàò ÏûàÏäµÎãàÎã§.\nÌà¨ÌëúÎäî Ï∑®ÏÜåÌï† Ïàò ÏóÜÏäµÎãàÎã§.");
            for (let j = 0; j < memberObjects.length; j++) {
                yield mafiaVoteMessageList[i].react(voteEmoji[j]);
            }
            emojiCollectorList.push(new discord_js_1.ReactionCollector(mafiaVoteMessageList[i], {
                filter: (reaction, user) => {
                    return voteEmoji.includes(reaction.emoji.name) && !user.bot;
                },
                time: 30000,
                max: 1,
                dispose: true,
            }));
            for (let j = 0; j < mafiaList.length; j++) {
                msgCollectorList.push(new discord_js_1.MessageCollector(mafiaList[j].dmChannel, {
                    filter: (msg, _collection) => {
                        return !msg.author.bot;
                    },
                }));
            }
            emojiCollectorList[i].on("collect", (reaction, _user) => __awaiter(this, void 0, void 0, function* () {
                votedAmount.push(voteEmoji.indexOf(reaction.emoji.name));
            }));
            if (mafiaList.length === 2) {
                msgCollectorList[i].on("collect", (msg, _collection) => {
                    if (i === 0)
                        mafiaList[1].dmChannel.send(`${mafiaList[0].user.username}: ${msg.content}`);
                    else if (i === 1)
                        mafiaList[0].dmChannel.send(`${mafiaList[1].user.username}: ${msg.content}`);
                });
            }
        }
        const result = yield new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < mafiaList.length; i++) {
                emojiCollectorList[i].on("end", (_collected, reason) => __awaiter(this, void 0, void 0, function* () {
                    if (votedAmount.length === mafiaList.length)
                        resolve(votedAmount);
                    if (reason == "time")
                        resolve(votedAmount);
                }));
            }
        }));
        msgCollectorList.every((collector) => collector.stop());
        return [msg, memberObjects, currentGamingGuildList, result];
    });
}
exports.Night_Mafia = Night_Mafia;
function Night_Doctor(msg, memberObjects, currentGamingGuildList, mafiaResult) {
    return __awaiter(this, void 0, void 0, function* () {
        yield msg.channel.send("ÏùòÏÇ¨Ïùò Ï∞®Î°ÄÏûÖÎãàÎã§.");
        const doctor = memberObjects.find((member) => {
            member.job == jobList.DOCTOR;
        });
        const embed = new discord_js_1.EmbedBuilder({
            title: "Ìà¨Ìëú (30Ï¥à)",
            description: "ÏπòÎ£åÌï† ÏÇ¨ÎûåÏùò Î≤àÌò∏Ïóê ÎßûÎäî Ïù¥Î™®Ìã∞ÏΩòÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.",
        }).addFields(memberObjects.map((member, i) => {
            return { name: member.user.username, value: `${i + 1}Î≤à` };
        }));
        const embeddedMessage = yield doctor.dmChannel.send({ embeds: [embed] });
        for (let i = 0; i < memberObjects.length; i++) {
            yield embeddedMessage.react(voteEmoji[i]);
        }
        const voteEmojiCollector = new discord_js_1.ReactionCollector(embeddedMessage, {
            filter: (reaction, user) => {
                return voteEmoji.includes(reaction.emoji.name) && !user.bot;
            },
            time: 30000,
            max: 1,
            dispose: true,
        });
        const result = yield new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            voteEmojiCollector.on("end", (collected) => __awaiter(this, void 0, void 0, function* () {
                const result = voteEmoji.indexOf(collected.at(0).emoji.name);
                resolve(result);
            }));
        }));
        return [msg, memberObjects, currentGamingGuildList, mafiaResult, result];
    });
}
exports.Night_Doctor = Night_Doctor;
function Night_Police(msg, memberObjects, currentGamingGuildList, mafiaResult, doctorResult) {
    return __awaiter(this, void 0, void 0, function* () {
        yield msg.channel.send("Í≤ΩÏ∞∞Ïùò Ï∞®Î°ÄÏûÖÎãàÎã§.");
        const police = memberObjects.find((member) => {
            member.job == jobList.POLICE;
        });
        const embed = new discord_js_1.EmbedBuilder({
            title: "Ìà¨Ìëú (30Ï¥à)",
            description: "Ï°∞ÏÇ¨Ìï† ÏÇ¨ÎûåÏùò Î≤àÌò∏Ïóê ÎßûÎäî Ïù¥Î™®Ìã∞ÏΩòÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.",
        }).addFields(memberObjects.map((member, i) => {
            return { name: member.user.username, value: `${i + 1}Î≤à` };
        }));
        const embeddedMessage = yield police.dmChannel.send({ embeds: [embed] });
        for (let i = 0; i < memberObjects.length; i++) {
            yield embeddedMessage.react(voteEmoji[i]);
        }
        const voteEmojiCollector = new discord_js_1.ReactionCollector(embeddedMessage, {
            filter: (reaction, user) => {
                return voteEmoji.includes(reaction.emoji.name) && !user.bot;
            },
            time: 30000,
            max: 1,
            dispose: true,
        });
        yield new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            voteEmojiCollector.on("end", (collected) => __awaiter(this, void 0, void 0, function* () {
                const result = voteEmoji.indexOf(collected.at(0).emoji.name);
                if (memberObjects[result].job == jobList.MAFIA_1 ||
                    memberObjects[result].job == jobList.MAFIA_2) {
                    resolve(yield police.dmChannel.send(`${memberObjects[result].user.username}ÏùÄ(Îäî) ÎßàÌîºÏïÑÏûÖÎãàÎã§.`));
                }
                else {
                    resolve(yield police.dmChannel.send(`${memberObjects[result].user.username}ÏùÄ(Îäî) ÎßàÌîºÏïÑÍ∞Ä ÏïÑÎãôÎãàÎã§.`));
                }
            }));
        }));
        return [
            msg,
            memberObjects,
            currentGamingGuildList,
            mafiaResult,
            doctorResult,
        ];
    });
}
exports.Night_Police = Night_Police;
function checkRevive(msg, memberObjects, currentGamingGuildList, mafiaResult, doctorResult) {
    return __awaiter(this, void 0, void 0, function* () {
        if (mafiaResult.length == 2) {
            if (mafiaResult[0] == mafiaResult[1]) {
                //Ìà¨ÌëúÍ∞Ä Í∞ôÏùå
                if (mafiaResult[0] == doctorResult) {
                    //ÏπòÎ£å ÏÑ±Í≥µ
                    yield msg.channel.send("ÏùòÏÇ¨Í∞Ä ÏπòÎ£åÏóê ÏÑ±Í≥µÌïòÏòÄÏäµÎãàÎã§.");
                }
                else {
                    yield msg.channel.send(`${memberObjects[mafiaResult[0]].user.username}Ïù¥(Í∞Ä) ÎßàÌîºÏïÑÏóêÍ≤å ÏÇ¥Ìï¥ÎãπÌñàÏäµÎãàÎã§.`);
                    memberObjects = memberObjects.filter((object) => {
                        return object != memberObjects[mafiaResult[0]];
                    });
                }
            }
            else
                yield msg.channel.send("ÏïÑÎ¨¥ ÏùºÎèÑ ÏùºÏñ¥ÎÇòÏßÄ ÏïäÏïòÏäµÎãàÎã§.");
        }
        else if (mafiaResult.length == 1) {
            if (mafiaResult[0] == doctorResult) {
                //ÏπòÎ£å ÏÑ±Í≥µ
                yield msg.channel.send("ÏùòÏÇ¨Í∞Ä ÏπòÎ£åÏóê ÏÑ±Í≥µÌïòÏòÄÏäµÎãàÎã§.");
            }
            else {
                yield msg.channel.send(`${memberObjects[mafiaResult[0]].user.username}Ïù¥(Í∞Ä) ÎßàÌîºÏïÑÏóêÍ≤å ÏÇ¥Ìï¥ÎãπÌñàÏäµÎãàÎã§.`);
                memberObjects = memberObjects.filter((object) => {
                    return object != memberObjects[mafiaResult[0]];
                });
            }
        }
        return [msg, memberObjects, currentGamingGuildList];
    });
}
exports.checkRevive = checkRevive;
